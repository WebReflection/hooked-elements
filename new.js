var hookedElements=function(e){"use strict";var t="function"==typeof cancelAnimationFrame,n=t?cancelAnimationFrame:clearTimeout,o=t?requestAnimationFrame:setTimeout;function s(e){var s,c,l,i,r;return u(),function(e,t,n){return l=e,i=t,r=n,c||(c=o(a)),--s<0&&h(!0),h};function a(){u(),l.apply(i,r||[])}function u(){s=e||1/0,c=t?0:null}function h(e){var t=!!c;return t&&(n(c),e&&a()),t}}var c=e=>({get:t=>e.get(t),set:(t,n)=>(e.set(t,n),n)})
/*! (c) Andrea Giammarchi - ISC */;let l=null;const i=c(new WeakMap),r=(e,t,n)=>{e.apply(t,n)},a={async:!1,always:!1},u=(e,t)=>"function"==typeof t?t(e):t,h=(e,t,n,o)=>{const c=l.i++,{hook:h,args:f,stack:d,length:p}=l;c===p&&(l.length=d.push({}));const g=d[c];if(g.args=f,c===p){const c="function"==typeof n,{async:l,always:f}=(c?o:n)||o||a;g.$=c?n(t):u(void 0,t),g._=l?i.get(h)||i.set(h,s()):r,g.f=t=>{const n=e(g.$,t);(f||g.$!==n)&&(g.$=n,g._(h,null,g.args))}}return[g.$,g.f]},f=new WeakMap,d=({hook:e,args:t})=>{e.apply(null,t)};function p(e){this.value!==e&&(this.value=e,f.get(this).forEach(d))}function g({hook:e}){return e===this.hook}const v=new WeakMap,m=c(v),y=()=>{},b=e=>(t,n)=>{const o=l.i++,{hook:c,after:i,stack:r,length:a}=l;if(o<a){const s=r[o],{update:c,values:l,stop:a}=s;if(!n||n.some(M,l)){s.values=n,e&&a(e);const{clean:o}=s;o&&(s.clean=null,o());const l=()=>{s.clean=t()};e?c(l):i.push(l)}}else{const o=e?s():y,a={clean:null,update:o,values:n,stop:y};l.length=r.push(a),(m.get(c)||m.set(c,[])).push(a);const u=()=>{a.clean=t()};e?a.stop=o(u):i.push(u)}},k=v.has.bind(v),w=b(!0),E=b(!1),A=(e,t)=>{const n=l.i++,{stack:o,length:s}=l;return n===s?l.length=o.push({$:e(),_:t}):t&&!t.some(M,o[n]._)||(o[n]={$:e(),_:t}),o[n].$};function M(e,t){return e!==this[t]}function O(e){return this.matches(e)}var $=Node.prototype.contains;const S="undefined"==typeof Promise?function(e){var t=[],n=!1;return e((function(){n=!0,t.splice(0).forEach(o)})),{then:o,catch(){}};function o(e){return n?setTimeout(e):t.push(e),this}}:Promise,{create:q,keys:C}=Object,_=new WeakMap,x=new Map,D="_"+Math.random(),F=new Set,L=[],W=[],N=[],{forEach:T}=N,P=e=>_.get(e)||N,R=new MutationObserver(e=>{for(let t=0,{length:n}=e;t<n;t++)P(e[t].target).forEach(X,e[t])});new MutationObserver(e=>{if(L.length)for(let t=0,{length:n}=e;t<n;t++){const{addedNodes:n,removedNodes:o}=e[t];T.call(n,V),T.call(o,j)}}).observe(document,{childList:!0,subtree:!0});const V=e=>{e.querySelectorAll&&(B(e,!1),K.call("connected",e),T.call(e.querySelectorAll(L),K,"connected"))},j=e=>{e.querySelectorAll&&(K.call("disconnected",e),T.call(e.querySelectorAll(L),K,"disconnected"))},z=e=>{L.forEach(U,e)},B=(e,t)=>{if(e.querySelectorAll){L.forEach(U,e);const n=e.querySelectorAll(L);T.call(n,z),t&&$.call(e.ownerDocument,e)&&(K.call("connected",e),T.call(n,K,"connected"))}},G=e=>{let t;const n={promise:new S(e=>t=e),resolve:t};return x.set(e,n),n},H=(e,t)=>{if(I(e))throw new Error("duplicated "+e);const n=[],o=q(null);for(let e=C(t),s=0,{length:c}=e;s<c;s++){let c=e[s];if(/^on/.test(c)&&!/Options$/.test(c)){const e=t[c+"Options"]||!1,s=c.toLowerCase();let l=s.slice(2);n.push({type:l,options:e}),o[l]=c,s!==c&&(l=c.slice(2,3).toLowerCase()+c.slice(3),o[l]=c,n.push({type:l,options:e}))}}if(n.length&&(t.handleEvent=function(e){this[o[e.type]](e)}),t.attributeChanged){const e={attributes:!0,attributeOldValue:!0},{observedAttributes:n}=t;(n||N).length&&(e.attributeFilter=n),t.observerDetails=e}L.push(e),W.push({listeners:n,definition:t,wm:new WeakMap}),J(document.documentElement),F.has(e)||(x.get(e)||G(e)).resolve()},I=e=>{const t=L.indexOf(e);return t<0?void 0:W[t].definition},J=e=>{L.length&&B(e,!0)};function K(e){P(e).forEach(Y,this)}function Q(e,t,n){for(let n=0,{length:o}=t;n<o;n++){const{type:o,options:s}=t[n];this.addEventListener(o,e,s)}const{observerDetails:o}=e;o&&R.observe(this,o),n.set(this,!0),_.set(this,P(this).concat(e)),e.init&&e.init()}function U(e,t){if(O.call(this,e)){const{definition:e,listeners:n,wm:o}=W[t];o.has(this)||Q.call(this,q(e,{element:{enumerable:!0,value:this},[D]:{writable:!0,value:""}}),n,o)}}function X(e){const{observerDetails:t}=e;if(t){const{attributeName:n,oldValue:o,target:s}=this,{attributeFilter:c}=t;(!c||-1<c.indexOf(n))&&e.attributeChanged(n,o,s.getAttribute(n))}}function Y(e){const t=e[this];t&&e[D]!=this&&(e[D]=this,t.call(e))}function Z(){te(this)}const ee=(e,t)=>H(e,"function"==typeof t?{init:Z,render:t}:(t.init||(t.init=Z),t)),te=e=>{const{disconnected:t,element:n,render:o}=e,s=(e=>{const t=[];return function n(){const o=l,s=[];l={hook:n,args:arguments,stack:t,i:0,length:t.length,after:s};try{return e.apply(null,arguments)}finally{l=o;for(let e=0,{length:t}=s;e<t;e++)s[e]()}}})(o.bind(e,n));return e.disconnected=()=>{k(s)&&(e=>{(v.get(e)||[]).forEach(e=>{const{clean:t,stop:n}=e;n(),t&&(e.clean=null,t())})})(s),t&&t.call(e)},(e.render=s)()};return e.createContext=e=>{const t={value:e,provide:p};return f.set(t,[]),t},e.define=ee,e.defineAsync=(e,t)=>{((e,t,n)=>{F.add(e),H(e,{init(){F.has(e)&&(F.delete(e),t().then(({default:t})=>{const o=L.indexOf(e);L.splice(o,1),W.splice(o,1),(n||H)(e,t)}))}})})(e,t,ee)},e.get=I,e.render=te,e.upgrade=J,e.useCallback=(e,t)=>A(()=>e,t),e.useContext=e=>{const{hook:t,args:n}=l,o=f.get(e),s={hook:t,args:n};return o.some(g,s)||o.push(s),e.value},e.useEffect=w,e.useLayoutEffect=E,e.useMemo=A,e.useReducer=h,e.useRef=e=>{const t=l.i++,{stack:n,length:o}=l;return t===o&&(l.length=n.push({current:e})),n[t]},e.useState=(e,t)=>h(u,e,void 0,t),e.whenDefined=e=>(x.get(e)||G(e)).promise,e}({});
